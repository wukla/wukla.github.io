{"pages":[{"title":"about","text":"helo guys","link":"/about/index.html"}],"posts":[{"title":"Java闭包与回调","text":"前言第一次知道闭包这个概念是在学习JavaScript的时候，相信接触过JavaScript的同学相信对闭包还有回调函数这两个名词一定不会陌生。深刻理解闭包这个概念，一定会使你的编程功力大增，而回调函数则是在编程中经常会用到的一种函数。然而在Java8以前，对于闭包这种函数式的编程方式支持很少，而且在其他语言中，回调通常利用指针进行。最近在学习《Java编程思想》的过程中，讲到内部类时就提到了Java的闭包与回调，下面就来分享一下学习的心得。 闭包在第一次学习闭包(closure)这个名词时，着实是一头雾水，我们来看一下百度百科上面的解释： 百度百科 -闭包包含自由（未绑定到特定对象）变量，这些变量不是在这个代码块内或者任何全局上下文中定义的，而是在定义代码块的环境中定义（局部变量）。“闭包” 一词来源于以下两者的结合：要执行的代码块（由于自由变量被包含在代码块中，这些自由变量以及它们引用的对象没有被释放）和为自由变量提供绑定的计算环境（作用域）。 再来看看维基百科上面的解释： 维基百科 -闭包（英语：Closure），又称词法闭包（Lexical Closure）或函数闭包（function closures），是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。所以，有另一种说法认为闭包是由函数和与其相关的引用环境组合而成的实体。闭包在运行时可以有多个实例，不同的引用环境和相同的函数组合可以产生不同的实例。 因此闭包就是在作用域中引用了自由变量(一开始存在于作用域内)的函数。闭包一旦形成，这个变量就会和函数一起存在，即使离开了作用域也不会消失。所以闭包=自由变量+代码块，闭包在形成之后自带运行环境。代码块就像是方便面的面饼，闭包就是自带调料包的方便面；代码块是发哥，闭包是高进——一个自带BGM的男人。就是因为这样，闭包在回调时不会丢失状态，这个后面通过书上的例子说明。 下面我们来看一下Java中的闭包是怎么实现的： 12345678910111213141516171819202122232425interface Incrementable{ void increment();}class MyIncrement{ public void increment(){System.out.println(\"Other operation\");} static void f(MyIncrement mi){mi.increment();}}class Callee extends MyIncrement{ //创建闭包的作用域 private int i = 0; //自由变量 public void increment(){ super.increment(); i++; System.out.println(i); } /** * 创建闭包的代码块 */ private class Closure implements Incrementable{ public void increment(){ Callee.this.increment(); } }} 在这个程序中，类closure一旦被创建，它就会形成拥有对外部类变量的引用的一个闭包。 还有一点就是，虽然闭包和匿名内部函数（或者说Java中的匿名内部类）经常会同时出现，但是这两个不是同一个概念。 回调回调函数是将函数指针调用的，假如将这个指针作为参数传递到另外一个函数中，那么在将来的某些时刻（或者说某些事件被触发）可以对函数进行调用。 这里提到，通常回调函数是由指针传递实现的，然而Java中没有指针，那对于上面例子中写的闭包来说，应该怎么进行回调呢？这里书中给出了了答案：在外部类Callee中加入下列方法 123public Incrementable getCallbackReference(){ return new Closure();} 这样虽然可以实现回调，但是一旦Callee的引用丢失，就无法再次找到闭包。 测试这里对类的输出值进行打印。再增加一个类caller用于在外部回调闭包。 1234567891011121314151617181920212223class caller{ private Incrementable callbackReference; public caller(Incrementable cbh){ this.callbackReference=cbh; } public void go(){ callbackReference.increment(callbackReference); }}public class close { public static void main(String[] args) { Callee c = new Callee();//i=0 MyIncrement.f(c);//i=1 caller caller1 = new caller(c.getCallbackReference()); caller caller2 = new caller(c.getCallbackReference()); caller1.go();//i = 2 caller1.go();//i = 3 c= null; System.gc(); caller2.go();//i = 4 }} 输入内容如下： 12345678Other operation1Other operation2Other operation3Other operation4 可以看到caller1和caller2得到了的变量同时指向了外围类的i，即使引用变量c被设成null，由于对象内部已经形成了闭包，因此i不会被垃圾回收机制回收，再次调用caller2的go()方法时会i就递增到了4。 我们回顾一下闭包的概念：要执行的代码块+环境作用域=闭包。虽然caller1中的closure对象和caller2中的closure对象是两个不同的对象，但根据前面闭包的概念来说，他们是属于同一个闭包，因为他们拥有同样的作用域和将要执行的代码块。 123456789101112131415161718private class Closure implements Incrementable{ public void increment(){ Callee.this.increment(); System.out.println(this);//打印当前对象地址 } }output: Other operation 1 Other operation 2 com.simple.Callee$Closure@6d06d69c Other operation 3 com.simple.Callee$Closure@6d06d69c Other operation 4 com.simple.Callee$Closure@7852e922 /**分别存在两个closure对象**/ lambda表达式与闭包闭包通常是由匿名函数来实现，在Java中，可以利用匿名内部类来实现闭包： 12345678 public Incrementable getCallbackReference(){ return new Incrementable() { @Override public void increment() { Callee.this.increment(); }}; } 然而，实现这个匿名内部类我们其实只不过是要实现一句话Callee.this.increment();加一个返回return new Incrementable，却要写这么一大堆代码，这对于简洁至上的我来说是绝对不能忍的。 在Java8之后，jdk提供了lambda表达式写法： 123public Incrementable getCallbackReference(){ return () -&gt;Callee.this.increment();} 输出结果与上文一模一样，由此可以看出lambda表达式在运行时会自动形成一个闭包。而且由lambda形成的闭包可以作为函数参数进行传递。 总结闭包这个概念最初出现于函数式语言中，如LISP等，但近几年来命令式语言也开始对函数式编程进行了支持，举例就是Java8新增的函数式接口与lambda等。虽然这里举例了Java在闭包的应用，但是总体来说Java并不适合函数式编程。最初看lambda表达式感觉怎么看怎么别扭，认为“这居然还是Java8新增的语法糖？”，但是在深入了解过lambda表达式的写法过后才发现，函数式编程如此美妙！ 参考链接维基百科 https://www.jianshu.com/p/c22db2a91989 https://baike.baidu.com/item/%E9%97%AD%E5%8C%85","link":"/2019/01/01/Java闭包与回调/"},{"title":"AOP加反射实现预插入操作","text":"前言最近对老项目的基础上扩展新的移动端，因此相当于建立一个全新工程。在每次进行插入操作时要求先将保存当前的时间和当前插入者的角色，在老项目中进行保存操作时要先调用preInsert()对保存对象进行赋值后再持久化到数据库中。但是我觉得这种方式并不简洁，而且扩展性并不好，所以我就想到了用aop加反射的方法对插入进行预处理。 运行环境 框架 版本 JDK 1.8.0_161 Springboot 2.2.0 SNAPSHOT Springdata-jpa springboot-starter-jpa 代码实现我的思路是这样的：创建一个自定义注解，通过注解的方式标识哪个方法需要进行插入的预处理工作。在切面中，利用前置通知在进入方法前通过反射获取参数对象进行赋值。下面详细看代码： 首先是定义的注解，value并没有用到，这个注解其实只是作为标识存在。 123456@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface preInsert { String value() default \"\";} 项目中的实体都是继承自父类BaseEntity&lt;T,ID extends Serizliable&gt;因此，插入时需要的createTime和createBy这些字段都放在父类中。方法中由joinPoint获取当前参数的对象，这里作了一个参数个数的判断，规定了参数只有一个对象值，去掉判断的话，就需要规定即将进行赋值的实体对象参数一定要放在第一位。 在获取到对象的引用之后，通过反射获得类型信息，再循环获取父类信息直到所有父类都不为BaseEntity时才捕获错误，之后就是常规的反射API调用了。 切面类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960@Aspect@Componentpublic class InsertAop { Logger log = LoggerFactory.getLogger(this.getClass()); /** * 切点：preInset注解 */ @Pointcut(\"@annotation(com.sinolvc.pgfp.app.commons.annotations.preInsert)\") public void insertPointCut() { } /** * 通知类型：before * 进行保存操作前，将当前时间放到要保存的实体中 * 适用于save(T extends BaseEntity),只有一个实体参数的情况 * 调用方法：setcreateDate,setUpdateDate * @param joinPoint */ @Before(\"insertPointCut()\") public void beforeInsert(JoinPoint joinPoint) { /** * 获取参数对象 */ Object[] args = joinPoint.getArgs(); if (args.length == 1) { Object arg = args[0]; /** * 得到参数的父类信息 */ Class&lt;?&gt; clazz = arg.getClass(); Date date = new Date(); /** * 假如获取的父类不是BaseEntity，就继续取父类，直到没有取到BaseEntity为止就抛出异常 */ try { Class&lt;?&gt; superClazz = clazz.getSuperclass(); while (!superClazz.getName().equals(\"com.sinolvc.pgfp.app.commons.base.BaseEntity\")) { superClazz = superClazz.getSuperclass(); } } catch (NullPointerException e) { log.error(\"save：类\" + clazz + \"没有继承 BaseEntity\"); } try { Method setCreateBy = superClazz.getDeclaredMethod(\"setCreateBy\",String.class); if(null != setCreateBy ) setCreateBy.invoke(arg,\"1\"); Method setCreateDate = superClazz.getDeclaredMethod(\"setCreateDate\", Date.class); if (null != setCreateDate) setCreateDate.invoke(arg, date); Method setUpdateDate = superClazz.getDeclaredMethod(\"setUpdateDate\", Date.class); if (null != setUpdateDate) setUpdateDate.invoke(arg, date); Method setDelFlag = superClazz.getDeclaredMethod(\"setDelFlag\",String.class); if(null != setDelFlag) setDelFlag.invoke(arg, Constant.DEL_FLAG_NORMAL); } catch (NoSuchMethodException e) { log.error(\"增强save方法：类\" + clazz + \"中没有 set 方法\"); } catch (IllegalArgumentException e) { log.error(\"增强save方法：类\" + clazz + \"中参数错误\"); } catch (IllegalAccessException | InvocationTargetException e) { log.error(\"增强save方法：类\" + clazz + \"中方法使用错误\"); } } }} 注解在逻辑层的方法上 12345@Override@preInsertpublic Job save(Job job){ return jobRepository.save(job);} 下面是BaseEntity的代码 1234567891011121314151617181920212223242526272829@MappedSuperclasspublic class BaseEntity implements Serializable { /** * 记录标识 */ @Id @GeneratedValue( generator = \"system-uuid\" ) @GenericGenerator(name = \"system-uuid\", strategy = \"uuid\") protected String id; /** * 创建日期 */ @Column( name = \"create_date\") protected Date createDate; /** * 更新日期 */ @Column( name = \"update_date\") protected Date updateDate; /** * 删除标记（0：正常；1：删除；2：审核） */ @Column( name = \"del_flag\") protected String delFlag; @Column(name=\"create_by\") protected String createBy; /***********getter and setter**********//*getset方法省略*/ Job实体的方法就不用给出了，注意要继承BaseEntity类。 总结最后发现通过这种方法来进行插入时性能会比直接调用赋值方法差一点点，但是还能接受，最重要的是这样写代码更加整洁，维护起来更加容易。","link":"/2019/01/12/AOP加反射实现预插入操作/"}],"tags":[{"name":"Thinking in Java","slug":"Thinking-in-Java","link":"/tags/Thinking-in-Java/"},{"name":"java8","slug":"java8","link":"/tags/java8/"},{"name":"lambda","slug":"lambda","link":"/tags/lambda/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"Spring","slug":"Spring","link":"/tags/Spring/"},{"name":"aop","slug":"aop","link":"/tags/aop/"}],"categories":[{"name":"读书笔记","slug":"读书笔记","link":"/categories/读书笔记/"},{"name":"项目笔记","slug":"项目笔记","link":"/categories/项目笔记/"}]}